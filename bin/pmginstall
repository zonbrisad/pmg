#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  [Description]
#  Linux admin help script
#
#  [Author]
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Date]
#    2016-xx-xx
#
#  [License]
#     MIT
#
#---------------------------------------------------------------------
# [Bashplates]
# This script is generated from bashplates template generator.
#
# Bashplates is developed by:
# Peter Malmberg <peter.malmberg@gmail.com>
#
# Bashplates is available at:
# https://github.com/zonbrisad/bashplates
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
#set -o pipefail

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------

serverPkgs=(               \
  "rdiff-backup"           \
  "nfs-common"             \
  "qemu-kvm"               \
  "virt-manager"           \
  "virt-top"               \
  "ssmtp"                  \
  "puppetmaster-passenger" \
  "mailutils"              \
)

basicPkgs=(         \
  "jed"             \
  "htop"            \
  "nmap"            \
  "puppet"          \
  "puppetmaster"    \
  "puppet-el"       \
  "lm-sensors"      \
  "apt-file"        \
)


develToolsPkgs=(    \
  "bison"           \
  "flex"            \
  "texinfo"         \
  "git"             \
	"gitk"            \
  "subversion"      \
  "meld"            \
	"doxygen"         \
)

develCPkgs=(        \
  "build-essential" \
  "gdb"             \
  "gdbserver"       \
  "autoconf"        \
  "cmake"           \
  "ccache"          \
  "colorgcc"        \
  "gettext"         \
  "libtool"         \
  "libexpat-dev"    \
  "splint"          \
  "pkg-config"      \
  "gperf"           \
  "libncurses5"     \
  "libncurses5-dev" \
  "lua5.1"          \
  "liblua5.1"       \
  "libglib2.0-0"    \
  "libglib2.0-dev"  \
  "qt5-default"     \
  "qt5-qmake"               \
  "libqt5core5a"            \
  "libqt5serialport5"       \
  "libqt5serialport5-dev"   \
	"qttools5-dev-tools"      \
  "libsqlite3-dev"          \
  "astudio"                 \
	"libgtk-3-dev"            \
	"libgtk-3-0-dbg"          \
	"glade"                   \
	"libc6-dev-amd64"         \
	"libgtk-3-dev"            \
	"astyle"                  \
	"libelf-dev"              \
	"freeglut3-dev"           \
)

armDevPkgs=(                \
  "build-essential"         \
  "gdb"                     \
  "gdbserver"               \
  "binutils-arm-none-eabi"  \ 
  "gcc-arm-none-eabi"       \
  "gdb-arm-none-eabi"       \
  "libnewlib-arm-none-eabi" \
  "openocd"                 \
)

avrDevPkgs=(                \
  "build-essential"         \
  "gdbserver"               \
  "avrdude"                 \
  "avr-libc"                \
  "gcc-avr"                 \
  "gdb-avr"                 \
  "avrdude"                 \
)

pythonDevPkgs=(                \
  "python"                     \
  "python-pip"                 \
  "python-qt4"                 \
  "python-qwt5-qt4"            \
  "python-numpy"               \
  "python-scipy"               \
  "python-serial"              \
  "python3"                    \
	"python3-serial"             \
  "python3-pip"                \
  "python3-pyqt5"              \
  "python3-pyqt5.qtserialport" \
  "python3-pyqt5.qtopengl"     \
  "python3-guiqwt"             \
  "python3-guidata"            \
  "python3-numpy"              \
  "python3-scipy"              \
	"pyqt5-dev-tools"            \
	"pyqt5-examples"             \
)

#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------


#
# Remove line in file containing a given string
# $1 file
# $2 string
#
removeLineContaining() {
  grep -v $2 $1 > $2 
}

#
# IP nr
#
#IP=`ip add show dev eth0 | grep "inet " | cut -c10-24 | cut -f1 -d'/'`
#DATE=`date`


mountServer() {  ## Add mount rule to fileserver in fstab
  bpAssertRoot
  bpMkDir /storage
  bpAppendIfNoSuchLine /etc/fstab  "fileserver:/storage  /storage nfs    auto   0 0"
}

##N- Install

addSambaUser() {
  smbpasswd -a pmg
}

#
# Installs array of packages
# 
# arg 1  array of packages
installG() {
  # first update all packages
  apt-get update
	
	# install all packages in list
  for pkg in ${@}; do
    apt-get -y install ${pkg}
  done
}

tools() {                  ## Install development toolls like git svn
  bpAssertRoot
  installG ${develToolsPkgs[@]} 
}

basic() {                   ## Install basic tools like editors
  bpAssertRoot
  installG ${basicPkgs[@]}
}

server() {                  ## Intstall server packages
  bpAssertRoot
  installG ${serverPkgs[@]}
}

cDevelop() {                ## Install packages for native C development 
  bpAssertRoot
  installG ${develCPkgs[@]}
}
				
ARMDevelop() {              ## Install ARM C development packages
  bpAssertRoot
  installG ${armDevPkgs[@]}
}

avrDevelop() {              ## Install AVR C development packages
  bpAssertRoot
  installG ${avrDevPkgs[@]}
}

java() {                    ## Install Java development packages
  bpAssertRoot
  apt-get -y install python-software-properties
  add-apt-repository ppa:webupd8team/java
  apt-get -y update
  apt-get -y install oracle-java8-installer
}

python() {                  ## Install python development packages
  bpAssertRoot
  installG ${pythonDevPkgs[@]}
	
	# Upgrade pip program
	pip  install --upgrade pip
	pip3 install --upgrade pip
}

users() {                   ## Create users and groups
  bpAssertRoot
  adduser lpmg -uid 1000
}


newDev() {                  ## Installs basic/tools/C development/python
  bpAssertRoot
	
	basic
	tools
	cDevelop
	python
	
}

WORK=~/Downloads

gitClonePull() {
	if [ ! -d $2 ]; then
	  git clone $1
	else
	  cd $2
		git pull
	fi
}


shellcheck() {  ## download compile and install latest version shellcheck

	dpkg-query -l cabal-install > /dev/null
	
	if [ "$?" -eq 1 ]; then
	  sudo apt-get -y install cabal-install  
	fi
	
	cabal update

  cd "$WORK"

	if [ ! -d "$WORK"/shellcheck ]; then
    git clone https://github.com/koalaman/shellcheck.git
	else
	  cd "$WORK"/shellcheck
		git pull
	fi

  cd "$WORK"/shellcheck

  cabal install

  # check if path is setup right
  which shellcheck

	if [ "$?" -eq 1 ]; then
	  echo
	  echo "Add the following to global PATH."
		echo 'export PATH="$HOME/.cabal/bin:$PATH"'
	fi

}

AVRSIMDIR=~/Downloads/simavr

avrsim() { ## Download compile and install avrsim
  #git clone https://github.com/buserror/simavr  ${AVRSIMDIR}
	cd ${AVRSIMDIR}
	ls
	make
	cd -
}


#---------------------------------------------------------------------
# Bashplate settings
#---------------------------------------------------------------------

bpInitSettings() { 

##V Script version info
VERSION="1.02"

##V Bashplate version
BPVERSION="1.11"

##V Usage info
USAGE="Usage: ${BPSCRIPTNAME} command [option]"

# Description text
DESC="Linux admin tools"

##V logfile (uncomment to use logfile)
#LOGFILE=${BPSCRIPTPATH}/${BPSCRIPTNAME}.log

##V Logging options (uncomment to activate logging parameters)
LOG_OK=1
LOG_INFO=1
LOG_WARNING=1
LOG_ERROR=1
LOG_CRITICAL=1

##V Lock file (uncomment to use lock file feature )
#LOCK_FILE=/tmp/${BPSCRIPTNAME}.lock

# Activate settings function (will create settings file when run)
#BPSETTINGS=1

bpSettingsDir=~/.config/bashplates
bpSettingsFile=${bpSettingsDir}/bashplates.conf

# Create settings file if non existent
#CREATEPLSETTINGS=1

}
#---------------------------------------------------------------------
# Bashplate Hooks
#---------------------------------------------------------------------

##V Default command (uncomment to use a default command )
DEFAULTCMD=help

##V Pre script hook, execute this function before every command
#PREHOOK=

##V Post script hook, execute this function after every command
#POSTHOOK=

##V Function to be executed before every other cmd except DEFAULT function
#PRECMDHOOK=

##V Function to be executed after every other function except DEFAULT function
#POSTCMDHOOK=

##V Function to be executed after information command
#INFOHOOK=

#---------------------------------------------------------------------
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$BP_E_OK"
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

##CN- IHELP Exit and cleanup

bpCleanUp() { ##D Cleanup function
  rm -f "$LOCK_FILE"    # remove Lock file
  echo -e "${E_SHOW}"     # Turn on cursor if turned of
}

#
# $1 exit code, if not given exit code is 0=SUCCESS
#
bpExit() { ##D Function for safely exiting script
  bpCleanUp

  # execute postscript hook if existing
  if [ -n "$POSTHOOK" ]; then
     ${POSTHOOK}
  fi

  # Check if argument is given
  if [ -z "$1" ]; then
    exit 0   # Success
  else
    exit "$1"
  fi

}

bpErrorExit() {  ##D Safely exit script with a error
  bpError "${1}"
  bpCleanUp
  exit 1
}

#---------------------------------------------------------------------
# Terminal codes
#---------------------------------------------------------------------

# ANSI foreground colors codes
#
E_BLACK=$'\e[0;30m'        # Black
E_RED=$'\e[0;31m'          # Red
E_GREEN=$'\e[0;32m'        # Green
E_YELLOW=$'\e[0;33m'       # Yellow
E_BLUE=$'\e[0;34m'         # Blue
E_MAGENTA=$'\e[0;35m'      # Magenta
E_CYAN=$'\e[0;36m'         # Cyan
E_GRAY=$'\e[0;37m'         # Gray
E_DARKGRAY=$'\e[1;30m'     # Dark Gray
E_BR_RED=$'\e[1;31m'       # Bright Red
E_BR_GREEN=$'\e[1;32m'     # Bright Green
E_BR_YELLOW=$'\e[1;33m'    # Bright Yellow
E_BR_BLUE=$'\e[1;34m'      # Bright Blue
E_BR_MAGENTA=$'\e[1;35m'   # Bright Magenta
E_BR_CYAN=$'\e[1;36m'      # Bright Cyan
E_WHITE=$'\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK=$'\e[40m'       # Black
E_ON_RED=$'\e[41m'         # Red
E_ON_GREEN=$'\e[42m'       # Green
E_ON_YELLOW=$'\e[43m'      # Yellow
E_ON_BLUE=$'\e[44m'        # Blue
E_ON_MAGENTA=$'\e[45m'     # Magenta
E_ON_CYAN=$'\e[46m'        # Cyan
E_ON_WHITE=$'\e[47m'       # White

# ANSI Text attributes
E_ATTR_BOLD=$'\e[1m'
E_ATTR_LOWI=$'\e[2m'
E_ATTR_UNDERLINE=$'\e[4m'
E_ATTR_BLINK=$'\e[5m'
E_ATTR_REVERSE=$'\e[7m'

# ANSI cursor operations
#
E_RETURN=$'\e[F'           # Move cursor to begining of line
E_UP=$'\e[A'               # Move cursor one line up
E_DOWN=$'\e[B'             # Move cursor one line down
E_FORWARD=$'\e[C'          # Move cursor forward
E_BACK=$'\e[D'             # Move cursor backward
E_HIDE=$'\e[?25l'          # Hide cursor
E_SHOW=$'\e[?25h'          # Show cursor

E_END=$'\e[m'              # Clear Attributes

# Default Bashplate colortheme
BP_C_OK=$E_BR_GREEN
BP_C_INFO=$E_BR_CYAN
BP_C_WARNING=$E_BR_YELLOW
BP_C_ERROR=$E_BR_RED
BP_C_CRITICAL=$E_ON_RED$E_WHITE
BP_C_LINE=$E_DARKGRAY
BP_C_LINE_TEXT=$E_YELLOW
BP_C_DESCRIPTION=$E_GREEN
BP_C_ID=$E_CYAN
BP_C_FILENAME=$E_BR_GREEN
BP_C_PATH=$E_GREEN

# Shellscript colorize colors
BP_C_RESERVED=$E_RED
BP_C_COMMENT=$E_CYAN
BP_C_STRING=$E_GREEN
BP_C_VAR=$E_BR_YELLOW

# Exit codes
#
BP_E_OK=0            # successful termination

#---------------------------------------------------------------------
# Bashplate internal functions
#---------------------------------------------------------------------

##CN- IHELP Printing functions

# Print text with row
#
# arg1 text to be printed
# arg2 text color
# arg3 line color
# arg4 middle character
# arg5 line character
#
bpPrintLineC() { ##D Print text with adjusted line after with selectable colors
  len1="${#1}"
  len4="${#4}"

  echo -en "${2}${1}${4}${3}"
  l=$((BPCOLUMNS - len1 - len4 - 3 ))
  seq -s"${5}" "${l}"|tr -d '[:digit:]'
  echo -en ${E_END} 
}

# Print text with row
#
# arg1 text to be printed
# arg2 text color
# arg3 line color
#
bpTextLineC() { ##D Print text with adjusted line after with selectable colors
  bpPrintLineC "$1" "$2" "$3" " " "-"
}

bpTextLine() { ##D Print text with line after
  bpTextLineC "$1" "${BP_C_LINE_TEXT}" "${BP_C_LINE}"
}

# Print a divider row
#
bpLine() { ##D Print a line
  bpPrintLineC "" "${BP_C_LINE}" "${BP_C_LINE}" "" "-"
}

# Legacy function (do not use in new applications)
#
printLine() {
  bpLine
}

# Generic command/description printout function
# 
# $1 command color
# $2 description color
# $3 command text
# $4 desccription text
#
bpPrintInfoGeneric() {
  printf "${1}  %-24.24s${E_END} ${2}%s${E_END}\n" "$3" "$4"
}


# Print text into two columns
#
# arg1 text for column 1
# arg2 text for column 2
#
bpPrintInfo() {
  bpPrintInfoGeneric "${BP_C_ID}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

bpPrintInfoAlt() {
  bpPrintInfoGeneric "${E_DARKGRAY}" "${BP_C_DESCRIPTION}" "$1" "$2"
}

# Print a variable + text into two columns
#
# $1 variable for column 1
# $2 text for column 2
# $3 optional text form column 1
#
bpPrintVar() {
  var="$1"      
  if [ "${!var}" ]; then
    if [ ! -z "$3" ]; then
      X=${3}
    else 
      X="${!var}"
    fi
    bpPrintInfo "$2" "${X}"
  else
    printf "${BP_C_ID}  %-24s${E_END} ${E_RED}N/A${E_END}\n" "$2"
  fi
}


# Colorize string with filename
#
# $1 string with filename to colorize
# ret colorized string
#
bpColorizeFile() { ##D Colorize string with filename
  if [ ! -z "$1" ]; then
    echo "${BP_C_PATH}$(dirname "$1")/${BP_C_FILENAME}$(basename "$1")${E_END}"
  fi
}


#
# $1 string to be filtered
#
bpFilterEscape() { ##D Filter escape characters from string
  echo "$1" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}
  

##CN- IHELP File operations

#
# $1 directory to change to
#
bpCd() { ##D Safe cd function (exits on fail)
  cd "$1" || bpExit "Failed to cd to [$1]"
}

# Create a directory if it does not exist
#
# $1 Directory to be created
#
bpMkDir() { ##D Create directory
  if [ ! -d "$1" ]; then
    bpInfo "Creating directory \"${1}\""
    mkdir -p "$1"
  fi
}

#
# $1 
# $2
#
bpLn() { ##D Create symbolic link
  bpInfo "Creating link \"${2}\""
  if [ ! -L "$1" ]; then
    ln -s "${1}" "${2}"
  fi
}

# 
# Copy file(s)
# 
# $1 file(s) to be copied
# $2 destination
#
bpCp() { ##D Copy file(s)
  bpInfo "Copying \"${1}\" to \"${2}\""
  cp -rf "$@"
}

#
# Move file(s)
#
# $1 file(s) to be moved
# $2 destination
bpMv() { ##D Move file(s)
  bpInfo "Moving file \"${1}\" \"${2}\""
  mv "$1" "$2"
}

# 
# Remove file(s)
# 
# $1 file(s) to be removed
#
bpRm() { ##D Remove file
  bpInfo "Removing file \"${1}\""
  rm -rf "${1}"
}

# Replace text in file
#
# $1 file 
# $2 text to replace
# $3 new text
#
bpReplace() {  ##D Replace text in file
  sed -i -e "s/${2}/${3}/g"  "$1"
}

# Replace entire line matching pattern
#
# $1 file 
# $2 pattern matching line
# $3 new text
#
bpReplaceLine() {  ##D Replace entire line in file
  sed -i -e "0,/${2}/s/${2}.*/${3}/" "${1}"
}

# Appends a line to a file if it is not present in that file.
#
# $1 file
# $2 line to append
#
bpAppendIfNoSuchLine() { ##D Append a line if it does not exist in file
  grep -q -F "$2" "$1" || echo "$2" >> "$1"
}

# Remove line in file containing a given string
#
# $1 file
# $2 string
#
bpRemoveLineContaining() { ##D Remove line in file if it contains given string
  grep -v "$2" "$1" > "${1}_tmp"
  mv -f "${1}_tmp" "${1}"
}

#
# Check if string exists in file
#
# $1 file
# $2 string
# return 1 for true, 0 for false
#
bpStrExist() { ##D Check if string exist in file
  
  if grep -q -F "$2" "$1" ; then
    echo "1"
  else
    echo "0"
  fi
}

##CN- IHELP Input

#
# Read string from commandline
#
# $1  Question string
# $2  Default value
# return string read from cmdline/default if enter pressed
#
bpRead() { ##D Read from commandline

  if [ "${2}" == "" ]; then
    read -erp "${1} >" result
  else
    read -erp "${1} [$2] >" result
    if [ "${result}" == "" ]; then
      result="${2}"
    fi
  fi

  echo "${result}"
}

#
# Read integer from commandline
#
# $1  Question string
# $2  Default value
# $3  min value
# $4  max value
# return integer read from cmdline/default if enter pressed
#
bpReadInt() { ##D Read integer from commandline
  while true; do
    if [ "${2}" == "" ]; then
      read -erp "${1} ($3-$4) >" result
      if [ "${result}" == "" ]; then
        result=$(($3 - 1))
      fi
    else
      read -erp "${1} ($3-$4) [$2] >" result
      if [ "${result}" == "" ]; then
        result="${2}"
      fi
    fi
    if [ $((result)) -ge "$3" ] && [ $((result)) -le "$4" ]; then
      break
    fi
  done
  echo "${result}"
}


#
# $1 question text
# $2 default answer 0 = yes, 1 = no
# return 0 = Yes, 1=No
#
bpReadYN() {  ##D Ask yes/no question generic 
  while true; do
  
    if [ "$2" -eq 1 ]; then 
      yn=$( bpRead "${1} [y/N]" )      
    else
      yn=$( bpRead "${1} [Y/n]" )
    fi
  
    case "$yn" in
      [Yy]* ) return 0;  break;;
      [Nn]* ) return 1;  break;;
      ""    ) return "$2"; break;;
      * ) echo "Please answer yes or no.";;
    esac
  done
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadY() { ##D Ask yes/no question default yes
  bpReadYN "$1" 0
  return $?
}

#
# $1 Question text
# return 0 = Yes, 1=No
#
bpReadN() { ##D Ask yes/no question default no
  bpReadYN "$1" 1
  return $?
}


#---------------------------------------------------------------------
#
#---------------------------------------------------------------------

# Settings file ------------------------------------------------------

##CN- BPSETTINGS Settings

bpAddSetting() { 

  # Check if setting exist in file
  S=$(bpStrExist "${1}" "${2}" )

  if [ "${S}" == "0" ]; then
    {
      echo "# ${4}" 
      echo "${2}=\"${3}\"" 
      echo 
    } >> "${1}"
  fi
}

bpAddSettings() { 
  bpAddSetting $bpSettingsFile "BP_NAME"    "John Doe"        "Name of user"
  bpAddSetting $bpSettingsFile "BP_EMAIL"   "JohnDoe@foo.bar" "Email of user"
  bpAddSetting $bpSettingsFile "BP_EDITOR"  "vi"              "Default editor"
  bpAddSetting $bpSettingsFile "BP_LICENSE" "MIT"             "Default project license"
  bpAddSetting $bpSettingsFile "BP_ORG"     "ACME"            "Default organisation"
}

# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
bpChSetting() {  
  SETTING="$2"
  VAL="$3"
  
  S=$(bpStrExist "${1}" "${2}" )
  if [ "${S}" == "0" ]; then
    bpAddSettings
  fi
  sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" "$1"
}

bpCreateSettings() {
  echo "Creating new bashplates settings file. ${bpSettingsFile}"
  bpMkDir ${bpSettingsDir}
          
  echo "# " >> ${bpSettingsFile}
  echo "# Bashplates common settings" > ${bpSettingsFile}
  echo "# " >> ${bpSettingsFile}
  echo      >> ${bpSettingsFile}

  bpAddSettings
}

bpLoadSettings() {
  if [ -n "${bpSettingsFile}" ]; then
    if [ -e "${bpSettingsFile}" ]; then
      source "${bpSettingsFile}"
    else
      bpCreateSettings
      source "${bpSettingsFile}"
    fi
  fi
}

printSettings() { ##C BPSETTINGS Print plate information
  bpTextLine "Bashplates settings"
  bpPrintVar BP_NAME      "Name:"
  bpPrintVar BP_EMAIL     "Email:"
  bpPrintVar BP_LICENSE   "Default license:"
  bpPrintVar BP_EDITOR    "Default editor"
  bpPrintVar BP_ORG       "Default organisation"
  bpLine
}

setname() { ##C BPSETTINGS Set name
  bpChSetting "${bpSettingsFile}" "BP_NAME" "\"${2}\""  
}

setemail() { ##C BPSETTINGS Set email address
  bpChSetting "${bpSettingsFile}" "BP_EMAIL" "\"${2}\""  
}

seteditor() { ##C BPSETTINGS Set default editor
  bpChSetting "${bpSettingsFile}" "BP_EDITOR" "\"${2}\""  
}

setlic() { ##C BPSETTINGS Set default license
  bpChSetting "${bpSettingsFile}" "BP_LICENSE" "\"${2}\""  
}

setorg() { ##C BPSETTINGS Set default organisation
  bpChSetting "${bpSettingsFile}" "BP_ORG" "\"${2}\""  
}


##-

# Logging ---------------------------------------------------------

##CN- IHELP Log functions

#
# Function logging to file
#
# Arg1 String to log to file
#
bpLog() { ##D Log to file command
  # check for LOGFILE variable
  if [ -n "$LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
    bpFilterEscape "$ts $1"  >> "${LOGFILE}"
  fi
}

bpLogOk() { ##D Log Ok message to file
  bpLog "[ Ok ] $1"
}

bpLogInfo() {  ##D Log Info message to file
  bpLog "[Info] $1"
}

bpLogWarning() {  ##D Log Warning message to file
  bpLog "[Warn] $1"
}

bpLogError() {  ##D Log Error message to file
  bpLog "[Erro] $1"
}

bpLogCritical() {  ##D Log Critical message to file
  bpLog "[Crit] $1"
}

log() { ##C LOGFILE View logfile
  if [ -n "$LOGFILE" ]; then
    if [ -f "${LOGFILE}" ]; then  # Check that logfile exists
      D=$(sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s|\[ Ok \]|\[\\${BP_C_OK} Ok \\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < "${LOGFILE}" )

      echo -e "$D"
    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

mlog() {   ##C LOGFILE Monitor logfile
  if [ -n "$LOGFILE" ]; then
    if [ -f "${LOGFILE}" ]; then  # Check that logfile exists
      tail -f "${LOGFILE}" | sed -r -e "s|\[Info\]|\[\\${BP_C_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${BP_C_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${BP_C_ERROR}Erro\\${E_END}\]|"    \
            -e "s|\[ Ok \]|\[\\${BP_C_OK}Erro\\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|"

    fi
  else
    bpInfo "Logging is not activated"
    bpExit
  fi
}

##CN- IHELP Message

bpOk() { ##D Success message
  if [ -n "$LOG_OK" ]; then
    bpLogOk "$1"
  fi  
  echo -e "[${BP_C_OK}Ok${E_END}] $1"
}

bpInfo() { ##D Info message
  if [ -n "$LOG_INFO" ]; then
    bpLogInfo "$1"
  fi
  echo -e "[${BP_C_INFO}Info${E_END}] $1"
}

bpWarning() { ##D Warning message
  if [ -n "$LOG_WARNING" ]; then
    bpLogWarning "$1"
  fi
  echo -e "[${BP_C_WARNING}Warning${E_END}] $1"
}

bpError() { ##D Error message
  if [ -n "$LOG_ERROR" ]; then
    bpLogError "$1"
  fi
  echo -e "[${BP_C_ERROR}Error${E_END}] $1"
}

bpCritical() { ##D Critical error message
  if [ -n "$LOG_CRITICAL" ]; then
    bpLogCritical "$1"
  fi
  echo -e "[${BP_C_CRITICAL}Critical${E_END}] $1"
  bpExit
}

# Various  ---------------------------------------------------------

##CN- IHELP Assert

bpAssertRoot() { ##D Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    bpExit "1"
  fi
}

bpAssertNoLockFile() { ##D Assert that lockfile is not present
  if [ -n "$LOCK_FILE" ]; then
    if [ -f "$LOCK_FILE" ]; then
      bpError "Script is already running. (${LOCK_FILE})"
      exit  "1" # do not use bpExit because lock file belongs to prexsisting process
    fi
    touch "$LOCK_FILE"
  fi
}

bpAssertRequiredProgs() { # Assert that required programs are available on the system (deprecated)
  bpAssertProgs "${REQUIRED_PROGRAMS[@]}"
}

#
# $1 string list of programs that are required
#
bpAssertProgs() { ##D Assert that required programs are available on the system
  things=("$@")
  e=0
  for thing in "${things[@]}" ;do
    hash "$thing" 2>&- || \
      { bpError "Required program \"$thing\" not found."; e=1; }
  done
  if [ $e -eq 1 ]; then
    bpExit 1
  fi
}

##CN- IHELP Debug/Controll

icheck() { ##D Make a shellcheck
  bpAssertProgs "shellcheck"
  shellcheck "$0"
}

irt() { ##D Remove tabs from script
  sed -i -e 's/\t/  /g' "${BPSCRIPTPATH}/${BPSCRIPTNAME}"
}

##CN- IHELP Help & info

printCommand() {
  help_line=$1
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$2"'//')
  bpPrintInfo "$help_command" "$help_info"
}

printCondCommand() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##C//' | awk '{print $1}')
  eval "D=\$$C"
  if [ -n "$D" ]; then
    help_command=$(echo "$help_line" | sed -s 's/(.*//')
    help_info=$(echo "$help_line" | sed -s 's/^.*'"$C"'//')
    bpPrintInfo "$help_command" "$help_info"
  fi
}

printCondCommandV() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##CV//' | awk '{print $1}')
  
  eval "D=\$$C"
  
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$C"'//')

  if [ -n "$D" ]; then
    bpPrintInfo "$help_command" "$help_info"
  else
    bpPrintInfoAlt "$help_command" "$help_info"
  fi
}

printCondLine() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##C-//' | awk '{print $1}')
  eval "D=\$$C"
  if [ -n "$D" ]; then
     bpLine
  fi
}

printNamedLine() {
  name=$(echo "$1" | sed -e 's/^.*##N-//' -e 's/^[ \t]*//' )
  bpTextLine "$name"
}

printCondNamedLine() {
  help_line="$1"
  C=$(echo "$1" | sed -s 's/^.*##CN-//' | awk '{print $1}')
  name=$(echo "$help_line" | sed -e 's/^.*'"$C"'//' -e 's/^[ \t]*//' )
  eval "D=\$$C"
  if [ -n "$D" ]; then
    bpTextLine "$name"
  fi
}

help() { ## Print this help information
  echo "$USAGE"
  echo -e "$DESC"
  echo 
  IFS=$'\n'
  SC="$1"
  help_lines=$(grep -h '##' "$0" | grep -v -e 'grep' -e '##D' -e '##V' -e '\*##C' -e '\*##C-' -e '\"##' -e '##N-//' -e 'help_line' -e 'printLine')
  for help_line in ${help_lines} ; do
    case "$help_line" in
      *"##-"*)   bpLine ;;
      *"##C-"*)  printCondLine       "$help_line" ;;
      *"##N-"*)  printNamedLine      "$help_line" ;;
      *"##CN-"*) printCondNamedLine  "$help_line" ;;
      *"##CV"*)  printCondCommandV    "$help_line" ;;
      *"##C"*)   printCondCommand    "$help_line" ;;
      *"##"*)    printCommand        "$help_line" '##' ;;
      *)
      ;;
    esac
  done
}

ihelp() { ##D Print internal help information  

  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpTextLine "$2"
    echo
    grep --no-filename -B 10 "$0" -e "${2}()" | grep "#" | grep -v "##"
    bpLine
    bpExit
  fi

  IFS=$'\n'
  SC="$1"

#  bpLine
  IHELP=1    # Force ihelp documentations
  LOGFILE=1  # Force log documentation

  help_lines=$(grep -h '##' "$0" | grep -v -e 'grep' -e '\*"##[ A-Z]"\*' -e 'help_line' -e ' printLine' -e 'awk' -e 'bpPrintInfo')
  for help_line in ${help_lines} ; do
    case "$help_line" in
#      "##-")    bpLine ;;
      *"##D"*)  printCommand  "$help_line" '##D' ;;
      *"##C-"*) printCondLine "$help_line" ;;
      *"##CN-"*) printCondNamedLine  "$help_line" ;;
      *"##C"*)   printCondCommand  "$help_line" ;;
      *)
      ;;
    esac
  done

  bpTextLine "Comments"
  bpPrintInfo "#" "Normal bash comment"
  bpPrintInfo "##" "Subcommand information comment (shown with help)"
  bpPrintInfo "##C" "Conditional subcommand comment (shown with help)"
  bpPrintInfo "##-" "Separator line (shown with help)"
  bpPrintInfo "##C-" "Conditional separator line (shown with help)"
  bpPrintInfo "##N-" "Named separator line (shown with help)"
  bpPrintInfo "##CN-" "Conditional named separator line (shown with help)"
  bpPrintInfo "##D" "Internal function comment (shown ihelp)"
  bpLine
}

iinfo() { ##D Show information about script
  bpTextLine "Script information"
  bpPrintVar "BPSCRIPTNAME"    "Script" "$( bpColorizeFile "${BPSCRIPTPATH}/${BPSCRIPTNAME}" )"
  bpPrintVar "VERSION"         "Script version" 
  bpPrintVar "BPVERSION"       "Template version"
  bpPrintVar "bpSettingsFile"  "Bashplate settings file" "$( bpColorizeFile ${bpSettingsFile} )"
  bpPrintVar "LOGFILE"         "Log file"  "$( bpColorizeFile "${LOGFILE}" )"
  bpPrintVar "LOCK_FILE"       "Lock file" "$( bpColorizeFile "${LOCK_FILE}" )"
  bpPrintVar "DEFAULTCMD"      "Default function" 
  bpPrintInfo "PID" "$$"  
  bpPrintVar "BPDATE" "Date" 
  bpPrintVar "BPTIME" "Time"

  if [ -n "${INFOHOOK}" ]; then
    bpTextLine "App. information"
    ${INFOHOOK}
  fi
  printSettings
}

#
iview() {  ##D View example
#  VF='s/\$[{]?[a-zA-Z0-9_]*[}]?/'"\\${BP_C_VAR}&\\${E_END}/" 
  # Singe command documentation
  if [ "$2" != "" ]; then
    echo
    bpTextLine "$2"
    echo
    grep --no-filename -A 60  "$0" -e "${2}()" | grep -B 60 -m 1 -x "}" | \
      sed -r -e "s/#.*/\\${BP_C_COMMENT}&\\${E_END}/"          \
             -e "s/\<echo\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<if\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<then\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<else\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<fi\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<do\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<done\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<elif\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<case\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<esac\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<for\>/\\${BP_C_RESERVED}&\\${E_END}/"     \
             -e "s/\<in\>/\\${BP_C_RESERVED}&\\${E_END}/"      \
             -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<time\>/\\${BP_C_RESERVED}&\\${E_END}/"    \
             -e "s/\<until\>/\\${BP_C_RESERVED}&\\${E_END}/"   \
             -e "s/\<select\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\<eval\>/\\${BP_C_RESERVED}&\\${E_END}/"  \
             -e "s/\".*\"/\\${BP_C_STRING}&\\${E_END}/"        \
             -e "s/[^=]*=/${BP_C_VAR}&\\${E_END}/"        \
#             -e $VF
#             -e 's/\$[{]?[a-zA-Z0-9]*[}]?/XXX/'
#             -e 's/$?/'"\\${BP_C_VAR}&\\${E_END}/" \
 #            -e "s/\<while\>/\\${BP_C_RESERVED}&\\${E_END}/"    \             
    bpLine
    bpExit
  fi
}

ivars() { ##D Print internal variables
  bpTextLine "Script variables"
  echo
  IFS=$'\n'
  help_lines=$( grep -v -e 'help_lines' -e 'help_line' "$0" | grep -A 1 '##V'   ) # | sed "s/--//" )
  for line in ${help_lines}; do
    if [ "$line" == "--" ]; then
      echo
    else
      help_line=$(echo "${line}" | sed -u -e "s/##V[ ]/${BP_C_DESCRIPTION}/i" -e "s/^.*=/${BP_C_ID}&${E_END}/i" -e "s/=/${E_END}=/" )
      echo -e "$help_line"
      echo -en "$E_END"
  fi
  done
  echo
}

version() { ## Print version information
  echo "$VERSION"
}

# Runs a function in this file as a command
bpRunCommand() {
  if [ "$BPARGUMENTS" -eq 0 ]; then

    # check for a default command
    if [ -n "$DEFAULTCMD" ]; then
      "$DEFAULTCMD" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      bpExit
    fi
    bpErrorExit "No command given"
  fi

  funks=$(grep "##" "$0" | grep -v grep | grep -v help_line)
  for line in ${funks}; do
    command=$(echo "$line" | sed -s 's/(.*//')
    if [ "$command" == "$1" ]; then

      # execute pre command hook  if existing
      if [ -n "$PRECMDHOOK" ]; then
        "${PRECMDHOOK}" "$command"
      fi

      # Check if command is conditional
      if [[ $( grep "${command}()" "$0" ) = *"##C"* ]]; then  

        # Check if condition is true and then execute else printout error message
        C=$( grep "${command}()" "$0"  | sed -s 's/^.*##C.//' | awk '{print $1}' )
        if [ -n "$C" ]; then
          eval "D=\$$C"

          if [ -n "$D" ]; then
            # execute command
            "${command}" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
          else
            bpError "Command \"$command\" not available right now."
          fi
        else
          bpError "Command \"$command\" is conditional, but is missing conditional variable"
        fi
      else 
        # command is not conditional, execute
        "${command}" "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"        
      fi

      # execute post command hook  if existing
      if [ -n "$POSTCMDHOOK" ]; then
        "${POSTCMDHOOK}" "$command"
      fi      
      bpExit
    fi
  done
  bpErrorExit "Command \"$1\" not found"
}

#---------------------------------------------------------------------
# Initiate internal variables
#---------------------------------------------------------------------

##V Directory where script is located
BPSCRIPTPATH=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

##V Name of script
BPSCRIPTNAME=$(basename "$0")

##V Number of arguments given to script
BPARGUMENTS=$#

##V Current date
BPDATE=$(date +"%Y-%m-%d")

##V Current time
BPTIME=$(date +"%H:%M:%S")

##V Number of columns in terminal
BPCOLUMNS=$(tput cols)

##V Number of lines in terminal
BPLINES=$(tput lines)


# Initiate bashplate settings
bpInitSettings


#---------------------------------------------------------------------
# Setup signal traps
#---------------------------------------------------------------------

trap  signalQuit SIGQUIT
trap  signalInt  SIGINT
trap  signalHup  SIGHUP
trap  signalTerm SIGTERM

#---------------------------------------------------------------------
# Load settings and execute script handler
#---------------------------------------------------------------------

# Load configuration file settings
bpLoadSettings

# execute prescript hook if existing
if [ -n "$PREHOOK" ]; then
  ${PREHOOK} "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
fi

# Run command parser
bpRunCommand "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"

# Exit cleanly
bpExit

##-
