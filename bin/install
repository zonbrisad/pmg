#!/bin/bash
# shellcheck disable=2034
#---------------------------------------------------------------------
#
#  [Description]
#  Linux admin help script
#
#  [Author] 
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Licence] 
#     MIT
#    
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
#set -o pipefail

# Directory where script is located
scriptPath=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

# Name of script
scriptName=$(basename "$0")

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------

serverPkgs=(               \
  "rdiff-backup"           \
  "nfs-common"             \
  "qemu-kvm"               \
  "virt-manager"           \
  "virt-top"               \
  "ssmtp"                  \
  "puppetmaster-passenger" \
  "mailutils"              \
)

basicPkgs=(         \
  "jed"             \
  "htop"            \
  "nmap"            \
  "puppet"          \
  "puppetmaster"    \
  "puppet-el"       \
  "lm-sensors"      \
  "apt-file"        \
)


develToolsPkgs=(    \
  "bison"           \
  "flex"            \
  "texinfo"         \
  "git"             \
  "subversion"      \
  "meld"            \
	"doxygen"         \
)

develCPkgs=(        \
  "build-essential" \
  "gdb"             \
  "gdbserver"       \
  "autoconf"        \
  "cmake"           \
  "ccache"          \
  "colorgcc"        \
  "gettext"         \
  "libtool"         \
  "libexpat-dev"    \
  "splint"          \
  "pkg-config"      \
  "gperf"           \
  "libncurses5"     \
  "libncurses5-dev" \
  "lua5.1"          \
  "liblua5.1"       \
  "libglib2.0-0"    \
  "libglib2.0-dev"  \
  "qt5-default"     \
  "qt5-qmake"               \
  "libqt5core5a"            \
  "libqt5serialport5"       \
  "libqt5serialport5-dev"   \
  "libsqlite3-dev"          \
  "astudio"                 \
)

armDevPkgs=(                \
  "build-essential"         \
  "gdb"                     \
  "gdbserver"               \
  "binutils-arm-none-eabi"  \ 
  "gcc-arm-none-eabi"       \
  "gdb-arm-none-eabi"       \
  "libnewlib-arm-none-eabi" \
  "openocd"                 \
)

avrDevPkgs=(                \
  "build-essential"         \
  "gdbserver"               \
  "avrdude"                 \
  "avr-libc"                \
  "gcc-avr"                 \
  "gdb-avr"                 \
  "avrdude"                 \
)

pythonDevPkgs=(                \
  "python"                     \
  "python-pip"                 \
  "python-qt4"                 \
  "python-qwt5-qt4"            \
  "python-numpy"               \
  "python-scipy"               \
  "python-serial"              \
  "python3"                    \
  "python3-pip"                \
  "python3-pyqt5"              \
  "python3-pyqt5.qtserialport" \
  "python3-pyqt5.qtopengl"     \
  "python3-guiqwt"             \
  "python3-guidata"            \
  "python3-numpy"              \
  "python3-scipy"              \
)

#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------


# Appends a line to a file if it is not present in that file.
# $1 file
# $2 line to append
appendIfNoSuchLine() {
  grep -q -F "$2" $1 || echo "$2" >> $1
}

#
# Remove line in file containing a given string
# $1 file
# $2 string
#
removeLineContaining() {
  grep -v $2 $1 > $2 
}

#
# IP nr
#
#IP=`ip add show dev eth0 | grep "inet " | cut -c10-24 | cut -f1 -d'/'`
#DATE=`date`

#
# Create dir if it does not exist
# $1 directory to be created
#
cDir() {
  if [ ! -d "$1" ]; then
    mkdir -p $1
  fi
}

mountServer() {  ## Add mount rule to fileserver in fstab
  assertRoot
  cDir /storage
  appendIfNoSuchLine /etc/fstab  "fileserver:/storage  /storage nfs    auto   0 0"
}

addSambaUser() {
  smbpasswd -a pmg
}

#
# Installs array of packages
# 
# arg 1  array of packages
installG() {
  # first update all packages
  apt-get update
	
	# install all packages in list
  for pkg in ${@}; do
    apt-get -y install ${pkg}
  done
}

tools() {                  ## Install development toolls like git svn
  assertRoot
  installG ${develToolsPkgs[@]} 
}

basic() {                   ## Install basic tools like editors
  assertRoot
  installG ${basicPkgs[@]}
}

server() {                  ## Intstall server packages
  assertRoot
  installG ${serverPkgs[@]}
}

cDevelop() {                ## Install packages for native C development 
  assertRoot
  installG ${develCPkgs[@]}
}
				
ARMDevelop() {              ## Install ARM C development packages
  assertRoot
  installG ${armDevPkgs[@]}
}

avrDevelop() {              ## Install AVR C development packages
  assertRoot
  installG ${avrDevPkgs[@]}
}

java() {                    ## Install Java development packages
  assertRoot
  apt-get -y install python-software-properties
  add-apt-repository ppa:webupd8team/java
  apt-get -y update
  apt-get -y install oracle-java8-installer
}

python() {                  ## Install python development packages
  assertRoot
  installG ${pythonDevPkgs[@]}
	
	# Upgrade pip program
	pip  install --upgrade pip
	pip3 install --upgrade pip
}

users() {                   ## Create users and groups
  assertRoot
  adduser lpmg -uid 1000
}


newDev() {                  ## Installs basic/tools/C development/python
  assertRoot
	
	basic
	tools
	cDevelop
	python
	
}

WORK=~/Downloads

gitClonePull() {
	if [ ! -d $2 ]; then
	  git clone $1
	else
	  cd $2
		git pull
	fi
}


shellcheck() {  ## download compile and install latest version shellcheck

	dpkg-query -l cabal-install > /dev/null
	
	if [ "$?" -eq 1 ]; then
	  sudo apt-get -y install cabal-install  
	fi
	
	cabal update

  cd "$WORK"

	if [ ! -d "$WORK"/shellcheck ]; then
    git clone https://github.com/koalaman/shellcheck.git
	else
	  cd "$WORK"/shellcheck
		git pull
	fi

  cd "$WORK"/shellcheck

  cabal install

  # check if path is setup right
  which shellcheck

	if [ "$?" -eq 1 ]; then
	  echo
	  echo "Add the following to global PATH."
		echo 'export PATH="$HOME/.cabal/bin:$PATH"'
	fi

}


#--------------------------------------------------------------------- 
# Bashplate settings
#---------------------------------------------------------------------

# Script version info
VERSION="1.01"

##V Bashplate version
templateVersion="1.08"   

##V Usage info
USAGE="Usage: ${scriptName} command [option]" 

# Description text
DESC="Linux admin tools"


##V logfile (uncomment to use logfile)
#LOGFILE=${scriptPath}/${scriptName}.log

##V Default command (uncomment to use a default command )
#DEFAULT=help

##V Programs that are required to run the script (uncomment to use)
#REQUIRED_PROGRAMS=(ls mv kalle)

##V Lock file (uncomment to use lock file feature )
#LOCK_FILE=/tmp/${scriptName}.lock

#--------------------------------------------------------------------- 
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
  exit "$EX_OK"
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

bpCleanUp() { ##D Cleanup function 
  rm -f "$LOCK_FILE"    # remove Lock file
}

safeExit() { ##D Function for safely exiting script
  bpCleanUp
  exit
}

errorExit() {
  bpCleanUp
  exit
}

#--------------------------------------------------------------------- 
# System functions and settings
#---------------------------------------------------------------------

# ANSI foreground colors codes
#

E_BLACK='\e[0;30m'        # Black 
E_RED='\e[0;31m'          # Red
E_GREEN='\e[0;32m'        # Green
E_YELLOW='\e[0;33m'       # Yellow
E_BLUE='\e[0;34m'         # Blue
E_MAGENTA='\e[0;35m'      # Magenta
E_CYAN='\e[0;36m'         # Cyan
E_GRAY='\e[0;37m'         # Gray
E_DARKGRAY='\e[1;30m'     # Dark Gray
E_BR_RED='\e[1;31m'       # Bright Red
E_BR_GREEN='\e[1;32m'     # Bright Green
E_BR_YELLOW='\e[1;33m'    # Bright Yellow
E_BR_BLUE='\e[1;34m'      # Bright Blue
E_BR_MAGENTA='\e[1;35m'   # Bright Magenta
E_BR_CYAN='\e[1;36m'      # Bright Cyan
E_WHITE='\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK='\e[40m'       # Black
E_ON_RED='\e[41m'         # Red
E_ON_GREEN='\e[42m'       # Green
E_ON_YELLOW='\e[43m'      # Yellow
E_ON_BLUE='\e[44m'        # Blue
E_ON_MAGENTA='\e[45m'     # Magenta
E_ON_CYAN='\e[46m'        # Cyan
E_ON_WHITE='\e[47m'       # White

# ANSI cursor operations
#
E_RETURN="\e[F"           # Move cursor to begining of line
E_UP="\e[A"               # Move cursor one line up
E_DOWN="\e[B"             # Move cursor one line down
E_FORWARD="\e[C"          # Move cursor forward
E_BACK="\e[D"             # Move cursor backward
E_HIDE="\e[?25l"          # Hide cursor 
E_SHOW="\e[?25h"          # Show cursor 

E_END="\e[m"              # Clear Attributes

# Message colors
E_INFO=$E_BR_CYAN
E_WARNING=$E_BR_YELLOW
E_ERROR=$E_BR_RED
E_CRITICAL=$E_ON_RED$E_WHITE

# Exit codes 
#
EX_OK=0            # successful termination 

##-

# Print a divider row
printLine() { ##D Print a line  
  echo -e "${E_BOLD_WHITE}------------------------------------------------------------------------------${E_END}"
}

# Print text into two columns
#
# arg1 text for column 1
# arg2 text for column 2
printInfo() {  
  printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_GREEN}%s${E_END}\n" "$1" "$2"
}

# Print a variable + text into two columns
#
# arg1 variable for column 1
# arg2 text for column 2
printVar() {
  var="$1"
  if [ "${!var}" ]; then
    printInfo "$2" "${!var}"
  else 
    printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_RED}N/A${E_END}\n" "$2"
  fi
}



#--------------------------------------------------------------------- 
# 
#---------------------------------------------------------------------

#
# Function logging to file
#
# Arg1 String to log to file
# 
bpLog() { ##D Log to file command
  # check for LOGFILE variable
  if [ -n "$LOGFILE" ]; then
    ts=$(date +"%Y-%m-%d %H:%M:%S")
     echo "$ts" "$1" >> "${LOGFILE}"
  fi
}

log() { ##C LOGFILE View logfile
  if [ -n "$LOGFILE" ]; then
    D=$(sed -r -e "s|\[Info\]|\[\\${E_INFO}Info\\${E_END}\]|"  \
            -e "s|\[Warn\]|\[\\${E_WARNING}Warn\\${E_END}\]|"  \
            -e "s|\[Erro\]|\[\\${E_ERROR}Erro\\${E_END}\]|"    \
            -e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
            -e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
            -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < "${LOGFILE}" ) 

    echo -e "$D"
  else
    bpInfo "Logging is not activated"
    exit
  fi
}

bpInfo() { ##D Info message 
  bpLog "[Info] $1"
  echo -e "[${E_INFO}Info${E_END}] $1"
}

bpWarning() { ##D Warning message
  bpLog "[Warn] $1"
  echo -e "[${E_WARNING}Warning${E_END}] $1"
}

bpError() { ##D Error message
  bpLog "[Erro] $1"
  echo -e "[${E_ERROR}Error${E_END}] $1"
}

bpCritical() { ##D Critical error message
  bpLog "[Crit] $1"
  echo -e "[${E_CRITICAL}Critical${E_END}] $1"
  safeExit
}

assertRoot() { ##D Assert that user is root
  if [ "$(whoami)" != root ]; then
    bpError "Must be root to use this command."
    safeExit
  fi
}


assertNoLockFile() { ##D Assert that lockfile is not present
  if [ -n "$LOCK_FILE" ]; then 
    if [ -f "$LOCK_FILE" ]; then
      echo -e "${E_ERROR}Script is already running. (${LOCK_FILE})${E_END} "
      exit  # do not use safeExit because lock belongs to other process
    fi
    touch "$LOCK_FILE"              
  fi
}

assertRequiredProgs() { ##D Assert that required programs are available on the system
  if [ -n "${REQUIRED_PROGRAMS}" ]; then
    for p in ${REQUIRED_PROGRAMS[@]}; do
      hash "$p" 2>&- || \
      { echo -e >&2 "${E_ERROR}Required program \"$p\" not found.${E_END}"; exit 1; }
    done
  fi
}

info() { ##D Show information about script
  printVar scriptName      "Script name" 
  printVar scriptPath      "Script path" 
  printVar VERSION         "Script version" 
  printVar templateVersion "Template version" 
  printVar LOGFILE         "Log file" 
  printVar LOCK_FILE       "Lock file" 
  printVar DEFAULT         "Default function" 
  printVar "REQUIRED_PROGRAMS" "Dependencies"
  printInfo "PID" $$  
  printVar DATE "Date" 
  printVar TIME "Time" 
}


# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
chSetting() { 
  SETTING="$2"
  VAL="$3"
  sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" "$1"
}

printCommand() { 
  help_line=$1
  help_command=$(echo "$help_line" | sed -s 's/(.*//')
  help_info=$(echo "$help_line" | sed -s 's/^.*'"$2"'//')
  printInfo "$help_command" "$help_info" 
}

printCondCommand() {
  help_line=$1
  C=$(echo "$1" | sed -s 's/^.*##C//' | awk '{print $1}')
  eval "D=\$$C"
  if [ -n "$D" ]; then
    help_command=$(echo "$help_line" | sed -s 's/(.*//')
    help_info=$(echo "$help_line" | sed -s 's/^.*'"$C"'//')
    printInfo "$help_command" "$help_info"
  fi
}

help() { ## Print this help information
  echo "$USAGE"
  echo -e "$DESC"
  echo 
  printf "%-20s  %s\n" "Command" "Help"
  printLine
  IFS=$'\n'
  SC=$1
  help_lines=$(grep -h '##' "$0" | grep -v grep | grep -v '##D' | grep -v '##V' | grep -v '\*##C' |  grep -v '\"##' | grep -v help_line | grep -v printLine)
  for help_line in ${help_lines[@]} ; do
#	for help_line in "${help_lines}" ; do
#  for help_line in "${help_lines[@]}" ; do
    case "$help_line" in
      *"##-"*) printLine ;;
      *"##C"*) printCondCommand "$help_line" ;;
      *"##"*)   printCommand "$help_line" '##' ;;
      *)    
      ;;   
    esac
  done 
}

ihelp() { ##D Print internal help information
  IFS=$'\n'
  SC=$1
  help_lines=$(grep -h '##' "$0" | grep -v grep | grep -v '\*"##[ A-Z]"\*' | grep -v help_line | grep -v printLine)
  for help_line in ${help_lines[@]}; do
    case "$help_line" in
      "##-") printLine ;;
      *"##D"*) 
          printCommand "$help_line" '##D' ;;
      *)    
      ;;   
    esac
  done 
}

vhelp() { ##D Print internal variable information
  IFS=$'\n'
  lines=$(grep -A 1 '##V' "$0" | grep -v 'lines')
  echo "$lines"
  for line in ${lines[@]}; do
    echo "$line"
#    case $line in
#      "##x") printLine ;;
#      *"##D"*) 
#          printCommand $help_line '##D' ;;
#      *)    
#      ;;   
#    esac
  done 

#  echo $lines
}

version() { ## Print version information
  echo "$VERSION"
}


# Runs a function in this file as a command
runCommand() {
  if [ "$bpArguments" -eq 0 ]; then
   
    # check for a default command
    if [ -n "$DEFAULT" ]; then
      $DEFAULT "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      safeExit
    fi
    
    echo -e "${E_ERROR}No command given${E_END}"
    help
    safeExit
  fi
  
  funks=$(grep "##" "$0" | grep -v grep | grep -v help_line)
  for line in ${funks[@]}; do
    command=$(echo "$line" | sed -s 's/(.*//')
    if [ "$command" == "$1" ]; then
      
      
      # execute prefunction if existing
      if [ -n "$PREFUNCTION" ]; then
        ${PREFUNCTION}
      fi
      
      # execute command
      ${command} "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"
      
      # execute postfunction if existing
      if [ -n "$POSTFUNCTION" ]; then
        ${POSTFUNCTION}
      fi
      
      safeExit
    fi
  done
  echo -e "${E_ERROR}Command not found${E_END}"
  help
  safeExit 
}

# Init 
#
DATE=$(date +"%Y-%m-%d")
TIME=$(date +"%H:%M:%S")

trap  signalQuit SIGQUIT
trap  signalInt  SIGINT
trap  signalHup  SIGHUP
trap  signalTerm SIGTERM

bpArguments=$#

# Run command parser
runCommand "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "${10}"

# Exit cleanly
safeExit


##-
