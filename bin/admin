#!/usr/bin/env bash
# shellcheck disable=2034
# shellcheck disable=1090
#---------------------------------------------------------------------
#
#  [Description]
#  Linux admin help script
#
#  [Author] 
#    Peter Malmberg <peter.malmberg@gmail.com>
#
#  [Licence] 
#     MIT
#    
#---------------------------------------------------------------------
#

# Display commands as they are executed
#set -o xtrace
# Display shell input lines as they are read
#set -v

# Exit script when a command fails. Append ||true if error is expected
#set -o errexit # || true
# Exit script when undeclared variable is used
#set -o nounset
# Exit script when pipe fails
set -o pipefail

# Directory where script is located
scriptPath=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

# Name of script
scriptName=$(basename $0)

#---------------------------------------------------------------------
# User defined Settings
#---------------------------------------------------------------------

userList=(                      \
  "5000 apmg APeter Malmberg peter.malmberg@gmail.com" \
  "5001 bpmg BPeter Malmberg peter.malmberg@gmail.com" \
)


groupList=(
  "10002 groupname1" \
  "10003 groupname2" \
)

#---------------------------------------------------------------------
# User defined functions
#---------------------------------------------------------------------


# Appends a line to a file if it is not present in that file.
# $1 file
# $2 line to append
appendIfNoSuchLine() {
  grep -q -F "$2" $1 || echo "$2" >> $1
}

#
# Remove line in file containing a given string
# $1 file
# $2 string
#
removeLineContaining() {
  grep -v $2 $1 > $2 
}

#
# IP nr
#
#IP=`ip add show dev eth0 | grep "inet " | cut -c10-24 | cut -f1 -d'/'`
#DATE=`date`

#
# Create dir if it does not exist
# $1 directory to be created
#
cDir() {
  if [ ! -d "$1" ]; then
    mkdir -p $1
  fi
}

mountServer() {  ## Add mount rule to fileserver in fstab
  assertRoot
  cDir /storage
  appendIfNoSuchLine /etc/fstab  "fileserver:/storage  /storage nfs    auto   0 0"
}

addSambaUser() {
  smbpasswd -a pmg
}


#
# Add a new user if not existing
#
# $1 = username
# $2 = uid
# $3 = name
# $4 = email
#
addUser() { 
  assertRoot
  getent passwd $2 > /dev/null
  if [ $? -ne 0 ]; then
    bpInfo "Adding user:  $1 $2 $3 $4"
    useradd $1 --create-home --uid $2
  else
    bpError "User "$2" already exists"
  fi
}

#
# Add group
# 
# $1 = user
# $2 = id
#
addGroup() {
  assertRoot
  getent group $1 > /dev/null
  if [ $? -ne 0 ]; then
    bpInfo "Adding group: "$1
    groupadd $1 --gid $2
  else
    bpError "Group $1 already exists"
  fi

}


#
# Remove user
#
# $1 = user
#
rmUser() {
  getent passwd $1 > /dev/null
  if [ $? -ne 0 ]; then
    bpError "User "$1" does not exist"
  else
    bpInfo "Removing user:  $1"
    deluser $1 --remove-home
  fi
}

#
# Remove group
#
# $1 = user
#
rmGroup() {
  getent group $1 > /dev/null
  if [ $? -ne 0 ]; then
    bpError "Group "$1" does not exist"
  else
    bpInfo "Removing group:  $1"
    delgroup $1 
    
  fi
}


rmu() { ## Remove  users and groups
  assertRoot
  IFS='\n'
  for u in ${userList[@]}; do

    UI=$(echo ${u} | awk '{print $1}' )
    UN=$(echo ${u} | awk '{print $2}' )
    FN=$(echo ${u} | awk '{print $3}' )
    SN=$(echo ${u} | awk '{print $4}' )
    UM=$(echo ${u} | awk '{print $5}' )		
    echo $UN 
    rmUser $UN 
  done

  for u in ${groupList[@]}; do
    GID=$(echo ${u} | awk '{print $1}' )
    GNAME=$(echo ${u} | awk '{print $2}' )
    rmGroup $GNAME
  done

}

cgroups() { ## Create groups
  assertRoot
  IFS=$'\n'
  for u in ${groupList[@]}; do
    GID=$(echo ${u} | awk '{print $1}' )
    GNAME=$(echo ${u} | awk '{print $2}' )
		
    echo ${GID} ${GNAME}
    	
    addGroup $GNAME $GID   
  done

}

cusers() { ## Create users
 assertRoot
  
  IFS=$'\n'
	for u in ${userList[@]}; do

		UI=$(echo ${u} | awk '{print $1}' )
		UN=$(echo ${u} | awk '{print $2}' )
		FN=$(echo ${u} | awk '{print $3}' )
		SN=$(echo ${u} | awk '{print $4}' )
		UM=$(echo ${u} | awk '{print $5}' )
		
		echo $UI $UN $FN $SN $UM
		addUser $UN $UI $FN $SN $UM
  done

  # Add user to group dialout (good for usb2serial adapters)
  usermod  -a -G dialout pmg

	exit
  assertRoot
  addGroup 10000 nisse
  addGroup 10000 nisse
  addUser 5000 pmg "Peter Malmberg"
  addUser 5001 lpmg 
  #adduser lpmg -uid 1000
}

#--------------------------------------------------------------------- 
# Bashplate settings
#---------------------------------------------------------------------

# Script version info
VERSION="1.00"

##V Bashplate version
BPVERSION="1.08"   

##V Usage info
USAGE="Usage: ${scriptName} command [option]" 

# Description text
DESC="Linux admin tools"


##V logfile (uncomment to use logfile)
#LOGFILE=${scriptPath}/${scriptName}.log

##V Default command (uncomment to use a default command )
#DEFAULT=help

##V Programs that are required to run the script (uncomment to use)
#REQUIRED_PROGRAMS=(ls mv kalle)

##V Lock file (uncomment to use lock file feature )
#LOCK_FILE=/tmp/${scriptName}.lock

#--------------------------------------------------------------------- 
# Signal traps
#---------------------------------------------------------------------

signalInt() {
  bpCleanUp
	exit $EX_OK
}

signalHup() {
  bpCleanUp
}

signalQuit() {
  echo "Quit"
  bpCleanUp
}

signalTerm() {
  echo "Term"
  bpCleanUp
}

bpCleanUp() { ##D Cleanup function 
  rm -f $LOCK_FILE    # remove Lock file
}

bpExit() { ##D Function for safely exiting script
  bpCleanUp
	exit
}

errorExit() {
  bpCleanUp
	exit
}

#--------------------------------------------------------------------- 
# System functions and settings
#---------------------------------------------------------------------

# ANSI foreground colors codes
#
E_BLACK='\e[0;30m'        # Black
E_RED='\e[0;31m'          # Red
E_GREEN='\e[0;32m'        # Green
E_YELLOW='\e[0;33m'       # Yellow
E_BLUE='\e[0;34m'         # Blue
E_MAGENTA='\e[0;35m'      # Magenta
E_CYAN='\e[0;36m'         # Cyan
E_GRAY='\e[0;37m'         # Gray
E_DARKGRAY='\e[1;30m'     # Dark Gray
E_BR_RED='\e[1;31m'       # Bright Red
E_BR_GREEN='\e[1;32m'     # Bright Green
E_BR_YELLOW='\e[1;33m'    # Bright Yellow
E_BR_BLUE='\e[1;34m'      # Bright Blue
E_BR_MAGENTA='\e[1;35m'   # Bright Magenta
E_BR_CYAN='\e[1;36m'      # Bright Cyan
E_WHITE='\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK='\e[40m'         # Black
E_ON_RED='\e[41m'           # Red
E_ON_GREEN='\e[42m'         # Green
E_ON_YELLOW='\e[43m'        # Yellow
E_ON_BLUE='\e[44m'          # Blue
E_ON_MAGENTA='\e[45m'       # Magenta
E_ON_CYAN='\e[46m'          # Cyan
E_ON_WHITE='\e[47m'         # White

# ANSI cursor operations
#
E_RETURN="\e[F"           # Move cursor to begining of line
E_UP="\e[A"               # Move cursor one line up
E_DOWN="\e[B"             # Move cursor one line down
E_FORWARD="\e[C"          # Move cursor forward
E_BACK="\e[D"             # Move cursor backward
E_HIDE="\e[?25l"          # Hide cursor 
E_SHOW="\e[?25h"          # Show cursor 

E_END="\e[m"              # Clear Attributes

# Message colors
E_INFO=$E_BR_CYAN
E_WARNING=$E_BR_YELLOW
E_ERROR=$E_BR_RED
E_CRITICAL=$E_ON_RED$E_WHITE

# Exit codes 
#
EX_OK=0            # successful termination 

##-

# Print a divider row
printLine() { ##D Print a line  
  echo -e "${E_BOLD_WHITE}------------------------------------------------------------------------------${E_END}"
}

# Print text into two columns
#
# arg1 text for column 1
# arg2 text for column 2
printInfo() {  
  printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_GREEN}%s${E_END}\n" "$1" "$2"
}

# Print a variable + text into two columns
#
# arg1 variable for column 1
# arg2 text for column 2
printVar() {
  var=$1
  if [ ${!var} ]; then
		printInfo "$2" "${!var}"
	else 
	  printf "${E_BR_CYAN}%-20s${E_END} ${E_BR_RED}N/A${E_END}\n" "$2"
	fi
}



#--------------------------------------------------------------------- 
# 
#---------------------------------------------------------------------

#
# Function logging to file
#
# Arg1 String to log to file
# 
bpLog() { ##D Log to file command
  # check for LOGFILE variable
	if [ -n "$LOGFILE" ]; then
	  ts=$(date +"%Y-%m-%d %H:%M:%S")
 	  echo $ts $1 >> ${LOGFILE}
	fi
}

log() { ##C LOGFILE View logfile
	if [ -n "$LOGFILE" ]; then
    D=$(sed -r -e "s|\[Info\]|\[\\${E_INFO}Info\\${E_END}\]|"  \
	          -e "s|\[Warn\]|\[\\${E_WARNING}Warn\\${E_END}\]|"  \
	          -e "s|\[Erro\]|\[\\${E_ERROR}Erro\\${E_END}\]|"    \
			  		-e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
				  	-e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
	          -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < ${LOGFILE} ) 

	  echo -e "$D"
	else
	  bpInfo "Logging is not activated"
		exit
	fi
}


bpInfo() { ##D Info message 
  bpLog "[Info] $1"
	echo -e "[${E_INFO}Info${E_END}] $1"
}

bpWarning() { ##D Warning message
  bpLog "[Warn] $1"
  echo -e "[${E_WARNING}Warn${E_END}] $1"
}

bpError() { ##D Error message
  bpLog "[Erro] $1"
  echo -e "[${E_ERROR}Erro${E_END}] $1"
}

bpCritical() { ##D Critical error message
  bpLog "[Crit] $1"
  echo -e "[${E_CRITICAL}Crit${E_END}] $1"
	bpExit
}

assertRoot() { ##D Assert that user is root
  if [ $(whoami) != root ]; then
	  bpError "Must be root to use this command."
    bpExit
  fi
}


assertLockFile() { ##D Assert that lockfile is not present
	if [ -n "$LOCK_FILE" ]; then 
	  if [ -f "$LOCK_FILE" ]; then
	    echo -e "${E_ERROR}Script is already running. (${LOCK_FILE})${E_END} "
		  exit  # do not use bpExit because lock belongs to other process
		fi
		touch $LOCK_FILE							
	fi
}


info() { ##D Show information about script
	printVar scriptName      "Script name" 
	printVar scriptPath      "Script path" 
	printVar VERSION         "Script version" 
	printVar BPVERSION       "Template version" 
	printVar LOGFILE         "Log file" 
	printVar LOCK_FILE       "Lock file" 
	printVar DEFAULT         "Default function" 
	printVar "REQUIRED_PROGRAMS" "Dependencies"
	printInfo "PID" $$	
	printVar DATE "Date" 
	printVar TIME "Time" 
}


# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
chSetting() { 
  SETTING=$2
	VAL=$3
	sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" $1
}

printCommand() { 
  help_line=$1
  help_command=$(echo $help_line | sed -s 's/(.*//')
	help_info=$(echo $help_line | sed -s 's/^.*'$2'//')
	printInfo $help_command $help_info 
}

printCondCommand() {
  help_line=$1
	C=$(echo $1 | sed -s 's/^.*##C//' | awk '{print $1}')
	eval "D=\$$C"
  if [ -n "$D" ]; then
	  help_command=$(echo $help_line | sed -s 's/(.*//')
		help_info=$(echo $help_line | sed -s 's/^.*'$C'//')
	  printInfo $help_command $help_info
	fi
}

help() { ## Print this help information
	echo $USAGE
	echo -e $DESC
	echo 
	printf "%-20s  %s\n" "Command" "Help"
	printLine
  IFS=$'\n'
	SC=$1
	help_lines=`grep -h '##' $0 | grep -v grep | grep -v '##D' | grep -v '##V' | grep -v '\*##C' |  grep -v '\"##' | grep -v help_line | grep -v printLine`
	for help_line in ${help_lines[@]}; do
		case $help_line in
		  *"##-"*) printLine ;;
			*"##C"*) printCondCommand $help_line ;;
			*"##"*)	 printCommand $help_line '##' ;;
			*)		
		  ;;	 
		esac
	done 
}

ihelp() { ##D Print internal help information
	IFS=$'\n'
	SC=$1
  help_lines=`grep -h '##' $0 | grep -v grep | grep -v '\*"##[ A-Z]"\*' | grep -v help_line | grep -v printLine`
	for help_line in ${help_lines[@]}; do
		case $help_line in
		  "##-") printLine ;;
			*"##D"*) 
			    printCommand $help_line '##D' ;;
			*)		
		  ;;	 
		esac
	done 
}

vhelp() { ##D Print internal variable information
	IFS=$'\n'
  lines=$(grep -A 1 '##V' $0 | grep -v 'lines')
	echo $lines
	for line in ${lines[@]}; do
	  echo $line
#		case $line in
#		  "##x") printLine ;;
#			*"##D"*) 
#			    printCommand $help_line '##D' ;;
#			*)		
#		  ;;	 
#		esac
	done 

#	echo $lines
}

version() { ## Print version information
  echo $VERSION
}

# Check if a number of required programs are available on the system
requiredPrograms() {
  if [ -n "${REQUIRED_PROGRAMS}" ]; then
    for p in ${REQUIRED_PROGRAMS[@]}; do
	    hash "$p" 2>&- || \
	    { echo -e >&2 "${E_ERROR}Required program \"$p\" not installed.${E_END}"; exit 1; }
	  done
	fi
}

# Runs a function in this file as a command
runCommand() {
#  echo $bpArguments
	if [ "$bpArguments" -eq 0 ]; then
	 
	  # check for a default command
	  if [ -n "$DEFAULT" ]; then
		  $DEFAULT "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "$10"
		  exit
		fi
		
	  echo -e ${E_ERROR}"No command given"${E_END}
		help
		bpExit
	fi
	
	# check for required programs 
	requiredPrograms

  funks=`grep "##" $0 | grep -v grep | grep -v help_line`
	for line in ${funks[@]}; do
	  command=`echo $line | sed -s 's/(.*//'`
		if [ "$command" == "$1" ]; then
      $command "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "$10"
			bpExit
		fi
	done
	echo -e ${E_ERROR}"Command not found"${E_END}
	help
	bpExit 
}

# Init 
#
DATE=$(date +"%Y-%m-%d")
TIME=$(date +"%H:%M:%S")

trap  signalQuit SIGQUIT
trap  signalInt  SIGINT
trap  signalHup  SIGHUP
trap  signalTerm SIGTERM

bpArguments=$#

# Run command parser
runCommand "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "$10"

# Exit cleanly
bpExit


##-
